<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Lumina Stack | 3D Arcade Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #0a0a0a; /* Lumina Dark */
            font-family: 'Poppins', sans-serif;
            user-select: none;
            touch-action: none; /* Prevent mobile scrolling */
        }

        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        /* HUD Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass through to game */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 40px;
            box-sizing: border-box;
        }

        #score-container {
            font-size: 6rem;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.1);
            text-shadow: 0 0 20px rgba(0, 123, 255, 0.5);
            transition: transform 0.1s;
            z-index: 10;
        }

        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 10, 0.85);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 20;
            transition: opacity 0.5s;
            padding-bottom: 150px; /* Space for footer on mobile */
        }

        .hidden {
            opacity: 0;
            pointer-events: none !important;
        }

        h1 {
            font-size: 3rem;
            color: white;
            margin: 0 0 20px 0;
            letter-spacing: 2px;
        }
        
        h1 span { color: #007BFF; }

        p { color: #9ca3af; font-size: 1.2rem; margin-bottom: 40px; }

        button {
            background: #007BFF;
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.2rem;
            font-weight: 600;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 10px 30px rgba(0, 123, 255, 0.4);
            transition: transform 0.2s, box-shadow 0.2s;
            font-family: 'Poppins', sans-serif;
        }

        button:hover {
            transform: scale(1.05);
            box-shadow: 0 15px 40px rgba(0, 123, 255, 0.6);
        }

        button:active { transform: scale(0.95); }

        /* NEW: Footer Logo Styles */
        .lumina-power-footer {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0.5rem;
            text-decoration: none;
            opacity: 0.6;
            color: #9ca3af;
            transition: opacity 0.3s ease;
            pointer-events: auto; /* Make it clickable */
            z-index: 21; /* Ensure it's above the background but below screens */
        }
        .lumina-power-footer:hover { opacity: 1; }
        .lumina-power-text { font-size: 0.7rem; font-weight: 400; }
        .lumina-logo-container { line-height: 1.2; text-align: left; }
        .lumina-logo-text { font-size: 0.9rem; font-weight: 700; color: white; letter-spacing: 0.05em; }
        .lumina-logo-text .accent { color: #007BFF; }
        .lumina-logo-tagline { font-size: 0.4rem; font-weight: 400; color: #9ca3af; letter-spacing: 0.2em; text-transform: uppercase; }


        /* Mobile optimization */
        @media (max-width: 600px) {
            #score-container { font-size: 4rem; }
            h1 { font-size: 2.5rem; }
            #start-screen, #game-over-screen { padding-bottom: 100px; }
        }
    </style>
    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="game-container"></div>

    <div id="ui-layer">
        <div id="score-container">0</div>
    </div>

    <!-- Start Screen -->
    <div id="start-screen">
        <h1>LUMINA <span>STACK</span></h1>
        <p>Click or Tap to Drop Blocks</p>
        <button id="start-btn">Play Now</button>
        
        <!-- NEW: Logo Snippet on Start Screen -->
        <a href="https://www.luminaweb.online/" target="_blank" rel="noopener noreferrer" class="lumina-power-footer" title="Powered by Lumina Web Solutions">
            <span class="lumina-power-text">Powered by</span>
            <div class="lumina-logo-container">
                <div class="lumina-logo-text"><span>LUMINA</span><span class="accent">.</span></div>
                <div class="lumina-logo-tagline">WEB SOLUTIONS</div>
            </div>
        </a>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="hidden">
        <h1>GAME <span>OVER</span></h1>
        <p>Final Score: <span id="final-score" class="text-white font-bold">0</span></p>
        <button id="restart-btn">Try Again</button>
         <!-- NEW: Logo Snippet on Game Over Screen -->
         <a href="https://luminaweb.vercel.app/" target="_blank" rel="noopener noreferrer" class="lumina-power-footer" title="Powered by Lumina Web Solutions">
            <span class="lumina-power-text">Powered by</span>
            <div class="lumina-logo-container">
                <div class="lumina-logo-text"><span>LUMINA</span><span class="accent">.</span></div>
                <div class="lumina-logo-tagline">WEB SOLUTIONS</div>
            </div>
        </a>
    </div>

    <script>
        // --- Game Configuration ---
        const CONFIG = {
            boxHeight: 1,
            originalBoxSize: 3,
            speed: 0.15, // Block movement speed
            colorBase: 220, // HSL Hue start (Blue)
            cameraZoom: 10
        };

        let scene, camera, renderer;
        let stack = []; // Array to hold block objects
        let overhangs = []; // Array for falling pieces
        let gameActive = false;
        let score = 0;
        let hue = CONFIG.colorBase;
        
        // Current moving block state
        let currentBlock = null;
        let moveAxis = 'x'; // 'x' or 'z'
        let direction = 1; // 1 or -1

        // DOM Elements
        const scoreEl = document.getElementById('score-container');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalScoreEl = document.getElementById('final-score');

        // --- Initialization ---
        function init() {
            // Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            
            // Fog for depth
            scene.fog = new THREE.Fog(0x0a0a0a, 10, 25);

            // Camera (Orthographic for isometric look)
            const aspect = window.innerWidth / window.innerHeight;
            const d = CONFIG.cameraZoom;
            camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
            camera.position.set(10, 10, 10);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('game-container').appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
            dirLight.position.set(10, 20, 10);
            scene.add(dirLight);
            
            // Lumina Blue Glow Light
            const spotLight = new THREE.SpotLight(0x007BFF, 1);
            spotLight.position.set(-10, 20, -5);
            spotLight.lookAt(0,0,0);
            scene.add(spotLight);

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('click', handleAction);
            document.addEventListener('touchstart', handleAction, { passive: false }); // Mobile touch

            document.getElementById('start-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                startGame();
            });
            
            document.getElementById('restart-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                resetGame();
            });

            // Render Loop
            renderer.setAnimationLoop(animation);
        }

        function startGame() {
            startScreen.classList.add('hidden');
            gameActive = true;
            addLayer(0, 0, CONFIG.originalBoxSize, CONFIG.originalBoxSize); // Base block (index 0)
            addLayer(0, 0, CONFIG.originalBoxSize, CONFIG.originalBoxSize); // First moving block (index 1)
        }

        function resetGame() {
            gameOverScreen.classList.add('hidden');
            
            // Clear existing blocks
            stack.forEach(block => scene.remove(block.mesh));
            overhangs.forEach(part => scene.remove(part.mesh));
            
            stack = [];
            overhangs = [];
            score = 0;
            hue = CONFIG.colorBase;
            scoreEl.innerText = score;
            
            // Reset camera
            camera.position.set(10, 10, 10);
            camera.lookAt(0, 0, 0);

            startGame();
        }

        function addLayer(x, z, width, depth) {
            const y = stack.length * CONFIG.boxHeight;
            
            // Determine position for new moving block
            let pos = { x: x, y: y, z: z };
            
            const layer = {
                mesh: createBox(width, CONFIG.boxHeight, depth, pos, hue),
                width: width,
                depth: depth,
                position: pos
            };
            
            scene.add(layer.mesh);
            stack.push(layer);

            // FIX: Only set up movement if it's NOT the base block (stack.length > 1)
            if (stack.length > 1) {
                currentBlock = layer;
                // Toggle axis
                moveAxis = moveAxis === 'x' ? 'z' : 'x';
                // Set start position for animation
                direction = -direction; // Alternate side
                const dist = 10 * direction;
                
                // Get the position of the PLACED block (index stack.length - 2)
                const prevLayer = stack[stack.length - 2]; 

                if (moveAxis === 'x') {
                    // Start position far out on X axis, aligned with prev block's Z
                    layer.mesh.position.x = prevLayer.position.x + dist;
                    layer.mesh.position.z = prevLayer.position.z; 
                }
                else {
                    // Start position far out on Z axis, aligned with prev block's X
                    layer.mesh.position.z = prevLayer.position.z + dist;
                    layer.mesh.position.x = prevLayer.position.x;
                }
            }
        }

        function createBox(w, h, d, pos, colorHue) {
            const geometry = new THREE.BoxGeometry(w, h, d);
            // Create a cool gradient-like material using HSL
            const material = new THREE.MeshLambertMaterial({ 
                color: new THREE.Color(`hsl(${colorHue}, 80%, 60%)`)
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(pos.x, pos.y, pos.z);
            return mesh;
        }

        function handleAction(e) {
            if (e.type === 'touchstart') e.preventDefault(); // Prevent zoom on double tap
            if (!gameActive) return;

            // Place the block
            if (stack.length > 1) { // Ignore first click on base
                const topLayer = stack[stack.length - 1];
                const prevLayer = stack[stack.length - 2];

                const delta = topLayer.mesh.position[moveAxis] - prevLayer.mesh.position[moveAxis];
                const overhang = Math.abs(delta);
                const size = moveAxis === 'x' ? topLayer.width : topLayer.depth;
                const overlap = size - overhang;

                if (overlap > 0) {
                    // Successful Stack
                    score++;
                    scoreEl.innerText = score;
                    scoreEl.style.transform = "scale(1.2)";
                    setTimeout(() => scoreEl.style.transform = "scale(1)", 100);
                    
                    // Cut the block
                    cutBlock(topLayer, prevLayer, delta, size, overlap, moveAxis);
                    
                    // Next block
                    hue += 5; // Shift color
                    const nextX = moveAxis === 'x' ? topLayer.mesh.position.x : prevLayer.mesh.position.x;
                    const nextZ = moveAxis === 'z' ? topLayer.mesh.position.z : prevLayer.mesh.position.z;
                    const nextW = moveAxis === 'x' ? overlap : topLayer.width;
                    const nextD = moveAxis === 'z' ? overlap : topLayer.depth;

                    addLayer(nextX, nextZ, nextW, nextD);

                } else {
                    // Missed completely
                    endGame();
                }
            }
        }

        function cutBlock(top, prev, delta, size, overlap, axis) {
            const newSize = overlap;
            const fallingSize = size - overlap;

            // Calculate new position of the centered block
            const newPos = prev.mesh.position[axis] + delta / 2;
            
            // Remove old mesh and replace with trimmed one
            scene.remove(top.mesh);
            
            // Update logic data
            top.width = axis === 'x' ? newSize : top.width;
            top.depth = axis === 'z' ? newSize : top.depth;
            top.position[axis] = newPos;
            
            top.mesh = createBox(top.width, CONFIG.boxHeight, top.depth, top.position, hue);
            scene.add(top.mesh);

            // Create Falling Part (Visual Effect)
            const fallingPos = { ...top.position };
            const sign = delta > 0 ? 1 : -1;
            fallingPos[axis] = newPos + (newSize / 2 + fallingSize / 2) * sign;
            
            const fallingW = axis === 'x' ? fallingSize : top.width;
            const fallingD = axis === 'z' ? fallingSize : top.depth;

            const fallingPart = {
                mesh: createBox(fallingW, CONFIG.boxHeight, fallingD, fallingPos, hue),
                axis: axis,
                sign: sign
            };
            scene.add(fallingPart.mesh);
            overhangs.push(fallingPart);
        }

        function endGame() {
            gameActive = false;
            finalScoreEl.innerText = score;
            gameOverScreen.classList.remove('hidden');
            
            // Make the last block fall
            const top = stack[stack.length - 1]; // Get the last moving block
            overhangs.push({
                mesh: top.mesh,
                axis: moveAxis, // Fall away from current movement
                sign: direction
            });
        }

        function animation() {
            if (!gameActive && overhangs.length === 0) return;

            // Animate current block sliding
            if (gameActive && currentBlock) {
                const time = Date.now() * 0.001;
                const speed = 4 + (score * 0.1); // Get faster
                const range = 5;
                
                // Move block back and forth
                const offset = Math.sin(time * speed) * range;
                
                if (moveAxis === 'x') {
                    currentBlock.mesh.position.x = stack[stack.length - 2].position.x + offset;
                    // Keep Z aligned with previous layer
                    currentBlock.mesh.position.z = stack[stack.length - 2].position.z;
                } else {
                    currentBlock.mesh.position.z = stack[stack.length - 2].position.z + offset;
                    // Keep X aligned with previous layer
                    currentBlock.mesh.position.x = stack[stack.length - 2].position.x;
                }
            }

            // Animate Camera (Follow the stack up)
            if (stack.length > 1) {
                const targetY = stack.length * CONFIG.boxHeight + 5;
                camera.position.y += (targetY - camera.position.y) * 0.05;
                camera.lookAt(0, stack.length * CONFIG.boxHeight - 2, 0);
            }

            // Animate Falling Pieces (Physics simulation)
            for (let i = overhangs.length - 1; i >= 0; i--) {
                const part = overhangs[i];
                part.mesh.position.y -= 0.3; // Gravity
                part.mesh.rotation.z += 0.1 * part.sign; // Spin
                part.mesh.rotation.x += 0.05;
                
                // Remove if off screen
                if (part.mesh.position.y < -20) {
                    scene.remove(part.mesh);
                    overhangs.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const d = CONFIG.cameraZoom;
            camera.left = -d * aspect;
            camera.right = d * aspect;
            camera.top = d;
            camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>